/* Generated file - DO NOT EDIT! */
/* Generated by utils/src/sep_rpc_gen/sep_rpc_gen.py@3343 at 2014-08-21 19:28:47.943000 */
/******************************************************************** 
* (c) Copyright 2011-2012 Discretix Technologies Ltd.              *
* This software is protected by copyright, international           * 
* treaties and patents.                                            * 
* Use of this Software as part of or with the CryptoCell product   * 
* is governed by the CryptoCell commercial end user license        * 
* agreement ("CryptoCell EULA").                                   * 
* It is possible that copies of this Software might be distributed * 
* under some type of GNU General Public License ("GPL").           * 
* Notwithstanding any such distribution under the terms of GPL,    * 
* GPL does not govern the use of this Software as part of or with  * 
* the CryptoCell product, for which a CryptoCell EULA is required. * 
* If CryptoCell EULA allows any copy or reproduction of this       * 
* Software, then such copy or reproduction must include this       * 
* Copyright Notice as well as any other notices provided           * 
* thereunder.                                                      * 
********************************************************************/
/* \file crys_rc4_seprpc_stub.c
 * SeP-RPC host wrappers/stubs implementation for CrysRc4 API */

#include <string.h>
#include "crys_rc4.h"
#include "crys_rc4_error.h"
#include "sep_rpc.h"
#include "driver_interface.h"
#include "crys_rc4_seprpc.h"


/************ CRYS_RC4_Init ***************/
CRYSError_t CRYS_RC4_Init(
	CRYS_RC4UserContext_t *ContextID_ptr,
	DxUint8_t Key_ptr[],
	DxUint32_t KeySizeInBytes)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RC4_InitParams params;

	/* Verify input parameters and copy into params. struct. */
	if (Key_ptr == NULL) {
		params.Key_ptr_null_flag = 1;
	} else {
		/* Verify array size of Key_ptr */
		SEP_RPC_ASSERT((KeySizeInBytes) <= (CRYS_RC4_MAX_KEY_SIZE_IN_BYTES), CRYS_RC4_DATA_IN_POINTER_INVALID_ERROR);
		memcpy(params.Key_ptr, Key_ptr, sizeof(DxUint8_t) * (KeySizeInBytes));
		params.Key_ptr_null_flag = 0;
	}

	params.KeySizeInBytes = cpu_to_le32(KeySizeInBytes);
	if (ContextID_ptr == NULL) {
		params.__ContextID_ptr_null_flag = 1;
	} else {
		params.__ContextID_ptr = *(ContextID_ptr);
		params.__ContextID_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RC4_Init);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRc4, SEPRPC_FUNC_ID_CRYS_RC4_Init,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RC4_INVALID_USER_CONTEXT_POINTER_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RC4_Init failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RC4_DATA_IN_POINTER_INVALID_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RC4_DATA_SIZE_ILLEGAL;
		default:
			return CRYS_RC4_INVALID_USER_CONTEXT_POINTER_ERROR;
		}
	}

	/* Copy back output parameters */
	if (ContextID_ptr == NULL) {
		params.__ContextID_ptr_null_flag = 1;
	} else {
		*(ContextID_ptr) = params.__ContextID_ptr;
		params.__ContextID_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RC4_Init */



/************ CRYS_RC4_Stream ***************/
CRYSError_t CRYS_RC4_Stream(
	CRYS_RC4UserContext_t *ContextID_ptr,
	DxUint8_t *DataIn_ptr,
	DxUint32_t DataInSize,
	DxUint8_t *DataOut_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct dxdi_memref memRefs[SEPRPC_MEMREF_NUM_CRYS_RC4_Stream];
	struct SepRpc_CRYS_RC4_StreamParams params;

	/* Verify input parameters and copy into params. struct. */
	params.DataInSize = cpu_to_le32(DataInSize);
	if (ContextID_ptr == NULL) {
		params.__ContextID_ptr_null_flag = 1;
	} else {
		params.__ContextID_ptr = *(ContextID_ptr);
		params.__ContextID_ptr_null_flag = 0;
	}


	/* User DMA buffers (memory references) */
	/* DataIn_ptr */
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].start_or_offset = (unsigned long)DataIn_ptr;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].size = DataInSize;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].dma_direction = DXDI_DATA_TO_DEVICE;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].ref_id = DXDI_MEMREF_ID_NULL;
	/* DataOut_ptr */
	memRefs[SEPRPC_MEMREF_IDX_DataOut_ptr].start_or_offset = (unsigned long)DataOut_ptr;
	memRefs[SEPRPC_MEMREF_IDX_DataOut_ptr].size = DataInSize;
	memRefs[SEPRPC_MEMREF_IDX_DataOut_ptr].dma_direction = DXDI_DATA_FROM_DEVICE;
	memRefs[SEPRPC_MEMREF_IDX_DataOut_ptr].ref_id = DXDI_MEMREF_ID_NULL;

	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RC4_Stream);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRc4, SEPRPC_FUNC_ID_CRYS_RC4_Stream,
		memRefs, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RC4_INVALID_USER_CONTEXT_POINTER_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RC4_Stream failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RC4_DATA_IN_POINTER_INVALID_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RC4_DATA_SIZE_ILLEGAL;
		default:
			return CRYS_RC4_INVALID_USER_CONTEXT_POINTER_ERROR;
		}
	}

	/* Copy back output parameters */
	if (ContextID_ptr == NULL) {
		params.__ContextID_ptr_null_flag = 1;
	} else {
		*(ContextID_ptr) = params.__ContextID_ptr;
		params.__ContextID_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RC4_Stream */



/************ CRYS_RC4_Free ***************/
CRYSError_t CRYS_RC4_Free(
	CRYS_RC4UserContext_t *ContextID_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_CRYS_RC4_FreeParams params;

	/* Verify input parameters and copy into params. struct. */
	if (ContextID_ptr == NULL) {
		params.__ContextID_ptr_null_flag = 1;
	} else {
		params.__ContextID_ptr = *(ContextID_ptr);
		params.__ContextID_ptr_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RC4_Free);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRc4, SEPRPC_FUNC_ID_CRYS_RC4_Free,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RC4_INVALID_USER_CONTEXT_POINTER_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RC4_Free failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RC4_DATA_IN_POINTER_INVALID_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RC4_DATA_SIZE_ILLEGAL;
		default:
			return CRYS_RC4_INVALID_USER_CONTEXT_POINTER_ERROR;
		}
	}

	/* Copy back output parameters */
	if (ContextID_ptr == NULL) {
		params.__ContextID_ptr_null_flag = 1;
	} else {
		*(ContextID_ptr) = params.__ContextID_ptr;
		params.__ContextID_ptr_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RC4_Free */



/************ CRYS_RC4 ***************/
CRYSError_t CRYS_RC4(
	DxUint8_t Key_ptr[],
	DxUint32_t KeySizeInBytes,
	DxUint8_t *DataIn_ptr,
	DxUint32_t DataInSize,
	DxUint8_t *DataOut_ptr)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct dxdi_memref memRefs[SEPRPC_MEMREF_NUM_CRYS_RC4];
	struct SepRpc_CRYS_RC4Params params;

	/* Verify input parameters and copy into params. struct. */
	if (Key_ptr == NULL) {
		params.Key_ptr_null_flag = 1;
	} else {
		/* Verify array size of Key_ptr */
		SEP_RPC_ASSERT((KeySizeInBytes) <= (CRYS_RC4_MAX_KEY_SIZE_IN_BYTES), CRYS_RC4_DATA_IN_POINTER_INVALID_ERROR);
		memcpy(params.Key_ptr, Key_ptr, sizeof(DxUint8_t) * (KeySizeInBytes));
		params.Key_ptr_null_flag = 0;
	}

	params.KeySizeInBytes = cpu_to_le32(KeySizeInBytes);
	params.DataInSize = cpu_to_le32(DataInSize);

	/* User DMA buffers (memory references) */
	/* DataIn_ptr */
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].start_or_offset = (unsigned long)DataIn_ptr;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].size = DataInSize;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].dma_direction = DXDI_DATA_TO_DEVICE;
	memRefs[SEPRPC_MEMREF_IDX_DataIn_ptr].ref_id = DXDI_MEMREF_ID_NULL;
	/* DataOut_ptr */
	memRefs[SEPRPC_MEMREF_IDX_DataOut_ptr].start_or_offset = (unsigned long)DataOut_ptr;
	memRefs[SEPRPC_MEMREF_IDX_DataOut_ptr].size = DataInSize;
	memRefs[SEPRPC_MEMREF_IDX_DataOut_ptr].dma_direction = DXDI_DATA_FROM_DEVICE;
	memRefs[SEPRPC_MEMREF_IDX_DataOut_ptr].ref_id = DXDI_MEMREF_ID_NULL;

	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_CRYS_RC4);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_CrysRc4, SEPRPC_FUNC_ID_CRYS_RC4,
		memRefs, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, CRYS_RC4_INVALID_USER_CONTEXT_POINTER_ERROR);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of CRYS_RC4 failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return CRYS_RC4_DATA_IN_POINTER_INVALID_ERROR;
		case SEPRPC_RET_ENORSC:
			return CRYS_RC4_DATA_SIZE_ILLEGAL;
		default:
			return CRYS_RC4_INVALID_USER_CONTEXT_POINTER_ERROR;
		}
	}

	return le32_to_cpu(params._funcRetCode);
} /* CRYS_RC4 */

