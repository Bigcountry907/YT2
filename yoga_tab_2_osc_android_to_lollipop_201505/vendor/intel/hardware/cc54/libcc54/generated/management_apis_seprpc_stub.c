/* Generated file - DO NOT EDIT! */
/* Generated by utils/src/sep_rpc_gen/sep_rpc_gen.py@3343 at 2014-08-21 19:28:06.465000 */
/******************************************************************** 
* (c) Copyright 2011-2012 Discretix Technologies Ltd.              *
* This software is protected by copyright, international           * 
* treaties and patents.                                            * 
* Use of this Software as part of or with the CryptoCell product   * 
* is governed by the CryptoCell commercial end user license        * 
* agreement ("CryptoCell EULA").                                   * 
* It is possible that copies of this Software might be distributed * 
* under some type of GNU General Public License ("GPL").           * 
* Notwithstanding any such distribution under the terms of GPL,    * 
* GPL does not govern the use of this Software as part of or with  * 
* the CryptoCell product, for which a CryptoCell EULA is required. * 
* If CryptoCell EULA allows any copy or reproduction of this       * 
* Software, then such copy or reproduction must include this       * 
* Copyright Notice as well as any other notices provided           * 
* thereunder.                                                      * 
********************************************************************/
/* \file management_apis_seprpc_stub.c
 * SeP-RPC host wrappers/stubs implementation for DxManagement API */

#include <string.h>
#include "dx_pal_types.h"
#include "dx_management.h"
#include "sep_rpc.h"
#include "driver_interface.h"
#include "management_apis_seprpc.h"


/************ DX_MNG_GetLcs ***************/
DxUint32_t DX_MNG_GetLcs(
	DxUint32_t *lcsVal)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_DX_MNG_GetLcsParams params;

	/* Verify input parameters and copy into params. struct. */
	if (lcsVal == NULL) {
		params.__lcsVal_null_flag = 1;
	} else {
		params.__lcsVal_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_DX_MNG_GetLcs);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_DxManagement, SEPRPC_FUNC_ID_DX_MNG_GetLcs,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, DX_FAILURE);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of DX_MNG_GetLcs failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return DX_FAILURE;
		case SEPRPC_RET_ENORSC:
			return DX_FAILURE;
		default:
			return DX_FAILURE;
		}
	}

	/* Copy back output parameters */
	if (lcsVal == NULL) {
		params.__lcsVal_null_flag = 1;
	} else {
		*(lcsVal) = le32_to_cpu(params.__lcsVal);
		params.__lcsVal_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* DX_MNG_GetLcs */



/************ DX_MNG_GetFwVersion ***************/
DxUint32_t DX_MNG_GetFwVersion(
	DxUint32_t *fwVer,
	DxUint32_t *romVer)
{
	DxDI_RetCode_t diRc;
	seprpc_retcode_t rpcRc;
	struct SepRpc_DX_MNG_GetFwVersionParams params;

	/* Verify input parameters and copy into params. struct. */
	if (fwVer == NULL) {
		params.__fwVer_null_flag = 1;
	} else {
		params.__fwVer_null_flag = 0;
	}

	if (romVer == NULL) {
		params.__romVer_null_flag = 1;
	} else {
		params.__romVer_null_flag = 0;
	}


	params.num_of_memrefs = cpu_to_le32(SEPRPC_MEMREF_NUM_DX_MNG_GetFwVersion);

	diRc = DxDI_SepRpcCall(SEPRPC_AGENT_ID_DxManagement, SEPRPC_FUNC_ID_DX_MNG_GetFwVersion,
		NULL, sizeof(params), (struct seprpc_params*)&params, &rpcRc);

	SEP_RPC_ASSERT(diRc == DXDI_RET_OK, DX_FAILURE);
	if (rpcRc != SEPRPC_RET_OK) {
		SEP_RPC_LOG("RPC of DX_MNG_GetFwVersion failed with RPC error code %d\n", rpcRc);
		switch (rpcRc) {
		case SEPRPC_RET_EINVAL:
			return DX_FAILURE;
		case SEPRPC_RET_ENORSC:
			return DX_FAILURE;
		default:
			return DX_FAILURE;
		}
	}

	/* Copy back output parameters */
	if (fwVer == NULL) {
		params.__fwVer_null_flag = 1;
	} else {
		*(fwVer) = le32_to_cpu(params.__fwVer);
		params.__fwVer_null_flag = 0;
	}

	if (romVer == NULL) {
		params.__romVer_null_flag = 1;
	} else {
		*(romVer) = le32_to_cpu(params.__romVer);
		params.__romVer_null_flag = 0;
	}


	return le32_to_cpu(params._funcRetCode);
} /* DX_MNG_GetFwVersion */

